= My Glimpse Inside The Ivory Tower Of Mathematics
Tony Locke
:doctype: book
:entails: &#x22A8;
:and: &#x2227;
:or: &#x2228;
:implies: &#x2192;
:not: &#x00AC;
:bicond: &#x2194;
:equiv: &#8801;
:isin: &#x2208;
:notin: &#x2209;
:sube: &#x2286;
:sub: &#x2282;
:ne: &#x2260;
:nequiv: &#x2262;
:brarr: &#x21A6;
:toc:

:numbered:
== Introduction

I'm a mathematical barbarian, but a few days ago I broke into the ivory tower of
mathematics and learnt some of the basics. In order to help me learn it, I wrote
this tutorial. It helped me, and perhaps you'll find it useful too.

=== Licence

This work is licensed under a
http://creativecommons.org/licenses/by-sa/4.0/[Creative Commons
Attribution-ShareAlike 4.0 International License].

=== Forum

If you have any comments on this book, please visit
https://groups.google.com/forum/\#!forum/glimpse-of-mathematics[https://groups.google.com/forum/#!forum/glimpse-of-mathematics].

The source code for the book is at
https://github.com/tlocke/maths[https://github.com/tlocke/maths].


=== Formats

This book is available in the following formats:

[horizontal]
Web:: http://maths.tlocke.org.uk/
EPUB:: http://maths.tlocke.org.uk/maths.epub

== Propositional Logic

[[img-russel]]
.http://commons.wikimedia.org/wiki/File:Russell_in_1924_01.jpg#mediaviewer/File:Russell_in_1924_01.jpg[Bertrand Russell in 1924] by Unknown - http://www.humanities.mcmaster.ca/~bertrand/later.html. Licensed under Public domain via http://commons.wikimedia.org/wiki/[Wikimedia Commons].
image::russell.jpg[Bertrand Russell in 1924]

=== True and false

In the realm of Propositional Logic, I found that they deal with things that are
either true or false. In the English language, sentences that are either true or
false are known as _statements_. Here are some sentences together with
explanations of whether they are statements or not:

[example]
How many miles to Crinnis?

This is a question, so not a statement.

[example]
Elephants have four legs.

Yay, an actual statement! It's a sentence that is either true or false.

[example]
Don't dilly-dally.

This isn't true or false, it sounds like someone admonishing somebody. Not a
statement.

[example]
The capital of France is Paris.

Yes, a statement.

[example]
He likes chocolate.

This sounds like a statement, but according to those logicians in the ivory
tower it doesn't count because it relies on knowing who '`he`' is.

[example]
Don't spoil the ship for a ha'peth of tar.

This is a proverb, not a statement.

I've got this nagging doubt in my mind. Most statements I can think of aren't
_totally_ ambiguous. Take the '`Elephants have four legs`' example. Maybe
there's a three legged elephant in existence, perhaps one in a zoo got
gangrene or something and had to have a leg amputated... Nevertheless, let's
suspend our disbelief and imagine all those perfect statements.

At that point, Alfred Tarski spoke up, '`What about this then?`'.

[example]
This statement is false.

Well, I'm not sure what to do. It seems like a statement, but if it's true then
it's false, and if it's false then it's true! Okay, let's get round it by saying
that this isn't really a statement. What do you think Taski? But Tarski's mind
was on other things...


:numbered!:
==== Questions

. Which of the following are statements?
.. Who is John Galt?
.. He's over there.
.. Three divided by three is one.
.. Belgium is a European country.
.. Praise be!
.. Blue is a colour.

. Are the following statements true or false?
.. Four is greater than two.
.. Tennis is a colour.
.. A square has eight sides.
.. A cube has eight corners.
.. Birmingham is a city in England.
.. The word '`rotavator`' is a
      http://en.wiktionary.org/wiki/palindrome[palindrome].


==== Answers

. {empty}
.. Not a statement.
.. Not a statement.
.. A statement.
.. A statement.
.. Not a statement.
.. A statement.
. {empty}
.. True.
.. False.
.. False.
.. True.
.. True.
.. True.


:numbered:
=== Compound Statements

It seems that the next thing the logicians do is string together simple
statements to make compound statements. So two simple statements might be:

[example]
Abelard likes coffee. +
Abelard likes cake.

And a compound statement formed from these two simple statements is:

[example]
Abelard likes coffee and Abelard likes cake.

We've joined the two simple statements together with the _logical conective_
'`and`'. This compound statement is true if both the simple statements are true,
otherwise it is false. Another compound statement we can make from our two
simple statements is:

[example]
Abelard likes coffee or Abelard likes cake.

Here's we've joined the two simple statements together with the logical
connective '`or`'. This compound statment is false if both simple statements are
false, otherwise it's true.


:numbered!:
==== Questions

. Are the following compound statements true or false?
.. The film Erin Brokovich stars Julia Roberts and 16 is greater than 4.
.. London is the capital of France or Paris is the capital of France.
.. Some people have brown eyes and humans lay eggs.
.. Four multiplied by two is twenty or it has never rained in Wales.
.. Toothpaste is harder than diamond and less than 100 films have ever been
   made.


==== Answers

. {empty}
.. True.
.. True.
.. False.
.. False.
.. False.


:numbered:
=== Formulas

Rather than always writing statements out in full, those work-shy logicians
write them in a shorthand. First they label each simple statement with a capital
letter of the alphabet. They call the label an _atomic formula_. Then they use
funny symbols to denote logical connectives. Here's a table of the symbols used
for logical connectives:

|===
| Logical connective | Symbol

| and                | {and}
| or                 | {or}
|===

So for the compound statement:

[example]
Abelard likes coffee and Abelard likes cake.

the two simple statements can have the atomic formulas P and Q:

[example]
P: Abelard likes coffee. +
Q: Abelard likes cake.

and the compound statement can be written as the _compound formula_:

[example]
(P {and} Q)

Now that we've said what P and Q stand for we can take this compound statement:

[example]
Abelard likes coffe or Abelard likes cake.

and write it using the atomic formulas to give the compound formula:

[example]
(P {or} Q)

You'll notice that the formulas have brackets round them. This is useful for
making the order of evaluation clear when formulas get more complicated.


:numbered!:
==== Questions

. Write the following compound statements as formulas:
.. The film Erin Brokovich stars Julia Roberts and 16 is greater than 4.
.. London is the capital of France or Paris is the capital of France.
.. Some people have brown eyes and humans lay eggs.
.. Four multiplied by two is twenty or it has never rained in Wales.
.. Toothpaste is harder than diamond and less than 100 films have ever been
   made.


==== Answers

. {empty}
.. P: The film Erin Brokovich stars Julia Roberts. +
   Q: 16 is greater than 4. +
   (P {and} Q)
.. A: London is the capital of France. +
   B: Paris is the capital of France. +
   (A {or} B)
.. P: Some people have brown eyes. +
   Q: Humans lay eggs. +
   (P {and} Q)
.. P: Four multiplied by two is twenty. +
   Q: It has never rained in Wales. +
   (P {or} Q)
.. P: Toothpaste is harder than diamond. +
   Q: Less than 100 films have ever been made. +
   (P {and} Q)


:numbered:
=== Ambiguous Compound Statements

Here's an ambiguous compound statement:

[example]
London is the capital of the UK or London is the capital of France and Paris is
the captital of the UK.

Assigning labels to the simple statements:

[example]
P: London is the capital of the UK. +
Q: London is the capital of France. +
R: Paris is the capital of the UK. +

the compound statement can be transated into two formulas with different
meanings:

[example]
((P {or} Q) {and} R) +
(P {or} (Q {and} R)

We know that P is true, Q is false and R is false. That means that the first formula evaluates to false:

[example]
((true {or} false) {and} false) +
(true {and} false) +
false

and the second formula evaluates to true:

[example]
(true {or} (false {and} false)) +
(true {or} false) +
true

I think what the Ivory Tower is teaching me here is that even though I started
out translating from English (what they call a natural language) to formulas
(what they call a formal language), it turns out that as well as being shorter,
formulas are unambiguous. It seems to me that the English statements are just a
jumping off point, and formulas are much better at describing this mathematical
realm. W00t, I said, `mathematical realm`!!!


:numbered!:
==== Questions

. For the following ambiguous compound statements in English, write down all the
  possible meanings as formulas.
.. Two is less than four or Alaska begins with A and purple is a number.
.. Purple is a number and Alaska begins with A or two is less than four.


==== Answers

. For the following ambiguous compound statements in English, write down all the
  possible meanings as formulas. +
  P: Two is less than four.
  Q: Alaska begins with A.
  R: Purple is a number.
.. Two is less than four or Alaska begins with A and purple is a number. +
   (P {or} (Q {and} R)) +
   ((P {or} Q) {and} R)
.. Purple is a number and Alaska begins with A or two is less than four. +
   (R {and} (Q {or} P)) +
   ((R {and} Q) {or} P)


:numbered:
=== Interpretations

Say you've got a formula:

[example]
(P {and} Q)

To logicians, an _interpretation_ is the assignment of true or false to P and Q.
So one interpretation is:

[example]
P is false +
Q is false

and another is:

[example]
P is true +
Q is false

so for a compound formula with two atomic formulas, there are four possible
interpretations:

|===
| P     | Q

| True  | True
| False | True
| True  | False
| False | False 
|===

and to make it easier to write they use T for true and F for false:

|===
| P | Q

| T | T
| F | T
| T | F
| F | F
|===

:numbered!:
==== Questions

. For a compound formula with three atomic formulas, there are eight possible
  interpretations. Show those eight possible interpretation in a table.


==== Answers

. For a compound formula with three atomic formulas, there are eight possible
  interpretations. Show those eight possible interpretation in a table.
+
|===
| P | Q | R

| T | T | T
| F | T | T
| T | F | T
| F | F | T
| T | T | F
| F | T | F
| T | F | F
| F | F | F
|===

:numbered:
=== Truth Tables

A truth table. A medieval device for extracting a confession? No, a
mathematical device for showing if a formula is true or false for every possible
<<_interpretations, interpretation>>. The truth table for (P {and} Q) is:

|===
| P | Q | (P {and} Q)

| T | T | T
| F | T | F
| T | F | F
| F | F | F
|===

so what we've done is written a row for each interpretation of P and Q, and then
in the final column put the value of (P {and} Q). The truth table for (P {or} Q)
is:

|===
| P | Q | (P {or} Q)

| T | T | T
| F | T | T
| T | F | T
| F | F | F
|===

You can use a truth table to show that (P {and} Q) means the same as
(Q {and} P):

|===
| P | Q | (P {and} Q) | (Q {and} P)

| T | T | T           | T
| F | T | F           | F
| T | F | F           | F
| F | F | F           | F
|===

For each interpretation, the last two columns are the same, and so (P {and) Q)
means the same as (Q {and} P).


:numbered!:
==== Questions

. Use a truth table to show that (P {or} Q) means the same thing as (Q {or} P).


==== Answers

. {empty}
+
|===
| P | Q | (P {or} Q) | (Q {or} P)

| T | T | T          | T
| F | T | T          | T
| T | F | T          | T
| F | F | F          | F
|===

For each row of the truth table, the last two columns are the same, and so
(P {or} Q) means the same as (Q {or} P).


:numbered:
=== Not

There's another logical connective called _not_, which has the symbol {not} and
the truth table:

|===
| P | {not}P

| T | F
| F | T
|===

Let us cast it loose amongst the other functions and employ the truth table
to see what results. Picking a formula at random, let's try:

[example]
({not}P {or} Q)

which gives the truth table:

|===
| P | Q | {not}P | ({not}P {or} Q)

| T | T | F      | T
| F | T | T      | T
| T | F | F      | F
| F | F | T      | T
|===

Let us now extract a full confession from:

[example]
{not}(P {or} Q)

which gives the truth table:

|===
| P | Q | (P {or} Q) | {not}(P {or} Q)

| T | T | T        | F
| F | T | T        | F
| T | F | T        | F
| F | F | F        | T
|===

One other thing, the first two logical connectives we encountered ({and} and
{or}) both acted on two formulas, and so they're known as _binary_ connectives.
The {not} connective acts on one formula and so is called a _unary_ connective.


:numbered!:
==== Questions

. Give the truth tables for:
.. {not}(P {and} Q)
.. (P {or} {not}Q)
.. {not}{not}P
.. {not}((P {or} Q) {or} R)
.. {not}((P {or} Q) {and} R)


==== Answers

. Give the truth tables for:
.. {not}(P {and} Q)
+
|===
| P | Q | {not}P | {not}(P {and} Q)

| T | T | F      | F
| F | T | T      | T
| T | F | F      | F
| F | F | T      | F
|===
+
.. (P {or} {not}Q)
+
|===
| P | Q | {not}Q | (P {or} {not}Q)

| T | T | F      | T
| F | T | F      | T
| T | F | T      | T
| F | F | T      | F
|===
+
.. {not}{not}P
+
|===
| P | {not}P | {not}{not}P

| T | F      | T
| F | T      | F
|===
+
.. {not}((P {or} Q) {or} R)
+
|===
| P | Q | R | (P {or} Q) | ((P {or} Q) {or} R) | {not}((P {or} Q) {or} R)

| T | T | T | T        | T               | F
| F | T | T | T        | T               | F
| T | F | T | T        | T               | F
| F | F | T | F        | T               | F
| T | T | F | T        | T               | F
| F | T | F | T        | T               | F
| T | F | F | T        | T               | F
| F | F | F | F        | F               | T
|===
+
.. {not}((P {or} Q) {and} R)
+
|===
| P | Q | R | (P {or} Q) | ((P {or} Q) {and} R) | {not}((P {or} Q) {and} R)

| T | T | T | T        | T                | F
| F | T | T | T        | T                | F
| T | F | T | T        | T                | F
| F | F | T | F        | F                | T
| T | T | F | T        | F                | T
| F | T | F | T        | F                | T
| T | F | F | T        | F                | T
| F | F | F | F        | F                | T
|===


:numbered:
=== Satisfaction

'`Sir, I demand satisfaction!`'. Yeah, we're not in Poldark, they don't watch
that in their Ivory Tower. Why waste time on TV dramas when you could be doing
maths?

An interpretation _satisfies_ a formula if it is true under that interpretation.
An example you say? An example? Okay, okay, you started off humble and now
you're making demands. I just feel you need to take a moment to think about
your attitude to this whole thing.

Under the interpretation:

[example]
P is false +
Q is true

the formula:

[example]
and(not(P), Q)

evaluates to:

[example]
and(not(false), true) +
and(true, true) +
true

since it's true, we can say that this interpretation satisfies this formula.
'`Could you show me another example please?`', '`Certainly dear reader`'.
Under the interpretation:

[example]
A is true +
B is true +
C is true +

the formula:

[example]
((B {or} A) {or} {not}C)

evaluates to:

[example]
((true {or} true) {or} {not}true) +
(true {or} false) +
true

and so this interpretation satisfies this formula.


:numbered!:
==== Questions

. For the following pairs of formulas and interpretations, show that the
  interpretation satisfies the formula:
.. (P {or} Q) when P is true and Q is false.
.. ({not}P {or} {not}Q) when P is true and Q is false.
.. ({not}A {and} B) when A is false and B is true.


==== Answers

. For the following pairs of formulas and interpretations, show that the
  interpretation satisfies the formula:
.. (P {or} Q) when P is true and Q is false. +
   (P {or} Q) +
   (true {or} false) +
   true +
   so the interpretation satisfies the formula.
.. ({not}P {or} {not}Q) when P is true and Q is false. +
   ({not}P {or} {not}Q) +
   ({not}true {or} {not}false) +
   (false {or} true) +
   true
   so the interpretation satisfies the formula.
.. ({not}A {and} B) when A is false and B is true. +
   ({not}A {and} B) +
   ({not}false {and} true) +
   (true {and} true) +
   true +
   so the interpretation satisfies the formula.


:numbered:
=== Falsification

This is the opposite of <<_satisfaction,satisfaction>>. An interpretation
_falsifies_ a formula if it is false under that interpretation. Under the
interpretation:

[example]
P is true +
Q is true

the formula:

[example]
({not}P {and} Q)

evaluates to:

[example]
({not}true {and} true) +
(false {and} true) +
false

since it's false, we can say that this interpretation falsifies this formula.
Under the interpretation:

[example]
A is true +
B is true +
C is true +

the formula:

[example]
((B {or} A) {and} {not}C)

evaluates to:

[example]
((true {or} true) {and} {not}true) +
(true {and} false) +
false

and so this interpretation satisfies this formula.


:numbered!:
==== Questions

. For the following pairs of formulas and interpretations, show that the
  interpretation falsifies the formula:
.. (P {or} Q) when P is false and Q is false.
.. ({not}P {or} {not}Q) when P is true and Q is true.
.. ({not}A {and} B) when A is false and B is false.


==== Answers

. For the following pairs of formulas and interpretations, show that the
  interpretation falsifies the formula:
.. (P {or} Q) when P is false and Q is false. +
   (P {or} Q) +
   (false {or} false) +
   false +
   so the interpretation falsifies the formula.
.. ({not}P {or} {not}Q) when P is true and Q is true. +
   ({not}P {or} {not}Q) +
   ({not}true {or} {not}true) +
   (false {or} false) +
   false
   so the interpretation falsifies the formula.
.. ({not}A {and} B) when A is false and B is false.
   ({not}A {and} B) +
   ({not}false {and} false) +
   (true {and} false) +
   false +
   so the interpretation falsifies the formula.


:numbered:
=== Valid Formula

The formula:

[example]
(P {or} {not}P)

has the truth table:

|===
| P | {not}P | (P {or} {not}P)

| T | F      | T
| F | T      | T
|===

which shows that every possible interpretation satisfies the formula. In the
Tower such a formula is called a _valid formula_.
 

:numbered!:
==== Questions

. Using a truth table, show that the following formula is valid:
.. ((P {or} Q) {or} {not}P)


==== Answers

. Using a truth table, show that the following formula is valid:
.. ((P {or} Q) {or} {not}P)
+
|===
| P | Q | {not}P | (P {or} Q) | ((P {or} Q) {or} {not}P)

| T | T | F      | T        | T
| F | T | T      | T        | T
| T | F | F      | T        | T
| F | F | T      | F        | T
|===
+
so the formula is valid.


:numbered:
=== Unsatisfiable Formula

The formula:

[example]
(P {and} {not}P)

has the truth table:

|===
| P | {not}P | (P {or} {not}P)

| T | F      | F
| F | T      | F
|===

which shows that every possible interpretation falsifies the formula. In the
Tower such a formula is called an _unsatisfiable formula_.


:numbered!:
==== Questions

. Using truth tables, show that the following formulas are unsatisfiable:
.. ((P {and} Q) {and} {not}(P {and} Q))
.. (P {and} (Q {and} {not}P))
.. (({not}P {and} {not}Q) {and} {not}({not}P {and} {not}Q))
.. (((P {and} {not}P) {and} Q) {and} R)


==== Answers

. Using truth tables, show that the following formulas are unsatisfiable:
.. ((P {and} Q) {and} {not}(P {and} Q))
+
|===
| P | Q | (P {and} Q) | {not}(P {and} Q) | ((P {and} Q) {and} {not}(P {and} Q))

| T | T | T           | F                | F
| F | T | F           | T                | F
| T | F | F           | T                | F
| F | F | F           | T                | F
|===
+
so unsatisfiable.
.. (P {and} (Q {and} {not}P))
+
|===
| P | Q | {not}P | (Q {and} {not}P) | (P {and} (Q {and} {not}P))

| T | T | F      | F                | F
| F | T | T      | T                | F
| T | F | F      | F                | F
| F | F | T      | F                | F
|===
+
so the formula is unsatisfiable.
.. (((P {and} {not}P) {and} Q) {and} R)
+
[cols="6*", options="header"]
|===
| P
| Q
| {not}P
| {not}Q
| ({not}P {and} {not}Q)
| {not}({not}P {and} {not}Q)
| (({not}P {and} {not}Q) {and} {not}({not}P {and} {not}Q))

| T | T | F | F | F | T | F
| F | T | T | F | F | T | F
| T | F | F | T | F | T | F
| F | F | T | T | T | F | F
|===
so the formula is unsatisfiable.
.. (((P {and} {not}P) {and} Q) {and} R)
+
[cols="7*", options="header"]
|===
| P
| Q
| R
| {not}P
| (P {and} {not}P)
| ((P {and} {not}P) {and} Q)
| (((P {and} {not}P) {and} Q) {and} R)

| T | T | T | F | F | F | F
| F | T | T | T | F | F | F
| T | F | T | F | F | F | F
| F | F | T | T | F | F | F
| T | T | F | F | F | F | F
| F | T | F | T | F | F | F
| T | F | F | F | F | F | F
| F | F | F | T | F | F | F
|===
so unsatisfiable.


:numbered:
=== Implies

There's another binary connective called _implies_ that has the truth table:

|===
| P | Q | (P {implies} Q)

| T | T | T
| F | T | T
| T | F | F
| F | F | T
|===

Take the two simple statements:

[example]
Abelard is at the cafe. +
The cafe is open.

Joining the two with an implication could give the compound statement:

[example]
Abelard is at the cafe only if the cafe is open.

If Abelard really is at the cafe and the cafe really is open, then this
compound statement is true. If Abelard isn't at the cafe, then whether or not
the cafe is open, the compound statement is still true (another way of putting
it is to say that if Abelard is not at the cafe, then this is still consistent
with with the statement that '`Abelard is at the cafe only when the cafe is
open`'). The only time the compound statement is false is if Abelard is at the
cafe but the cafe is not open.

There are a few different ways that '`implies`' occurs in English. The
statement:

[example]
Abelard is at the cafe only if the cafe is open.

could be written in these alternative ways:

[example]
* If Abelard is at the cafe then the cafe is open.
* Abelard being at the cafe implies that the cafe is open.
* The cafe being open is a necessary condition for Abelard to be at the cafe.
* The cafe being open follows from Abelard being at the cafe.

Here's an example of {implies} in action. The formula:

[example]
((P {and} {not}Q) {implies} Q)

Has the truth table:

|===
| P | Q | {not}Q | (P {and} {not}Q) | ((P {and} {not}(Q)) {implies} Q)

| T | T | F      | F                | T
| F | T | F      | F                | T
| T | F | T      | T                | F
| F | F | T      | F                | T
|===

Another example; the truth table for (Q {implies} (P {and} {not}Q)) is:

|===
| P | Q | {not}Q | (P {and} {not}Q) | (Q {implies} (P {and} {not}Q))

| T | T | F      | F              | F
| F | T | F      | F              | F
| T | F | T      | T              | T
| F | F | T      | F              | T
|===

:numbered!:
==== Questions

. Write the following English statements as logical formulas:
.. The washing is out only if it's a dry day.
.. If Keith is in Bath, then Keith is in England.
.. The sky being red at night implies that the shepherds are delighted.
. Create a truth table for each of the following formulas:
.. implies(not(P), Q)
.. implies(Q, not(Q))
.. or(implies(P, Q), P)
.. implies(not(and(P, Q)), or(not(P), not(Q)))
.. implies(and(P, implies(P, Q)), not(P))


==== Answers

. Write the following English statements as logical formulas:
.. The washing is out only if it's a dry day. +
   P: The washing is out. +
   Q: It's a dry day. +
   (P {implies} Q)
.. If Keith is in Bath, then Keith is in England. +
   A: Keith is in Bath. +
   B: Keith is in England. +
   (A {implies} B)
.. The sky being red at night implies that the shepherds are delighted.
   A: The sky is red at night. +
   B: The shepherds are delighted. +
   (A {implies} B)
. Create a truth table for each of the following formulas:
.. ({not}P {implies} Q)
+
|===
| P | Q | {not}P | ({not}P {implies} Q)

| T | T | F      | T
| F | T | T      | T
| T | F | F      | T
| F | F | T      | F
|===
.. (Q {implies} {not}Q)
+
|===
| Q | {not}Q | (Q {implies} {not}Q)

| T | F      | F
| F | T      | T
|===
.. ((P {implies} Q) {or} P)
+
|===
| P | Q | (P {implies} Q) | ((P {implies} Q) {or} P)

| T | T | T             | T
| F | T | T             | T
| T | F | F             | T
| F | F | T             | T
|===
.. ({not}(P {and} Q) {implies} ({not}P {or} {not}Q))
+
[cols="8*", options="header"]
|===
| P
| Q
| (P {and} Q)
| {not}(P {and} Q)
| {not}P
| {not}Q
| ({not}P {or} {not}Q)
| ({not}(P {and} Q) {implies} ({not}P {or} {not}Q))

| T | T | T | F | F | F | F | T
| F | T | F | T | T | F | T | T
| T | F | F | T | F | T | T | T
| F | F | F | T | T | T | T | T
|===
.. implies(and(P, implies(P, Q)), not(P))
+
[cols="6*", options="header"]
|===
| P
| Q
| (P {implies} Q)
| {not}P
| (P {and} (P {implies} Q))
| ((P {and} (P {implies} Q)) {implies} {not}P)

| T | T | T | F | T | F
| F | T | F | T | F | T
| T | F | F | F | F | T
| F | F | F | T | F | T
|===


:numbered:
=== Equals

The _equals_ function is a binary function with the truth table:

|===
| P | Q | equals(P, Q)

| 1 | 1 | 1
| 0 | 1 | 0
| 1 | 0 | 0
| 0 | 0 | 1
|===

Translating from English to a formula, the sentence:

[example]
It's Christmas Day if and only if it's the 25th of December.

is written:

[example]
P: It's Christmas Day. +
Q: It's the 25th of December. +
equals(P, Q)

which of course is true. An example that is false is:

[example]
It's Christmas Day if and only if it's the 2nd of March.

which is written:

[example]
P: It's Christmas Day. +
Q: It's the 2nd of March. +
equals(P, Q)


:numbered!:
==== Questions

. Translate the following English sentences into formulas:
.. The bike's back brake comes on if, and only if, the left brake lever is
   applied.
.. The fridge light is on if, and only if, the fridge door is open.
. Give the truth table for each of the following formulas:
.. equals(A, and(B, C))
.. or(B, equals(A, B))
.. and(P, not(equals(P, or(Q, P))))
.. and(equals(Q, not(P)), equals(P, not(not(Q))))


==== Answers

. {empty}
.. The bike's back brake comes on if, and only if, the left brake lever is
   applied. +
   P: The bike's back brake comes on. +
   Q: The left brake lever is applied. +
   equals(P, Q)
.. The fridge light is on if, and only if, the fridge door is open. +
   P: The fridge light is on. +
   Q: The fridge door is open. +
   equals(P, Q)
. Give the truth table for each of the following formulas:
.. equals(A, and(B, C))
+
|===
| A | B | C | and(B, C) | equals(A, and(B, C)

| 1 | 1 | 1 | 1         | 1
| 0 | 1 | 1 | 1         | 0
| 1 | 0 | 1 | 0         | 0
| 0 | 0 | 1 | 0         | 1
| 1 | 1 | 0 | 0         | 0
| 0 | 1 | 0 | 0         | 1
| 1 | 0 | 0 | 0         | 0
| 0 | 0 | 0 | 0         | 1
|===
+
.. or(B, equals(A, B))
+
|===
| A | B | equals(A, B) | or(B, equals(A, B))

| 1 | 1 | 1            | 1
| 0 | 1 | 0            | 1
| 1 | 0 | 0            | 0
| 0 | 0 | 1            | 1
|===
+
.. and(P, not(equals(P, or(Q, P))))
+
|===
| P
| Q
| or(Q, P)
| equals(P, or(Q, P)
| not(equals(P, or(Q, P))
| and(P, not(equals(P, or(Q, P))))

| 1 | 1 | 1 | 1 | 0 | 0
| 0 | 1 | 1 | 0 | 1 | 0
| 1 | 0 | 1 | 1 | 0 | 0
| 0 | 0 | 0 | 1 | 0 | 0
|===
+
.. and(equals(Q, not(P)), equals(P, not(not(Q))))
+
|===
| P
| Q
| not(P)
| equals(Q, not(P))
| not(Q)
| not(not(Q))
| equals(P, not(not(Q)))
| and(equals(Q, not(P)), equals(P, not(not(Q))))

| 1 | 1 | 0 | 0 | 0 | 1 | 1 | 0
| 0 | 1 | 1 | 1 | 0 | 1 | 0 | 0
| 1 | 0 | 0 | 1 | 1 | 0 | 0 | 0
| 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0
|===

:numbered:
=== Identity

If two formulas are an _identity_, then the formula formed by joining them with
the '`equals`' function will be valid. For example, if the pair of formulas:

[example]
implies(A, B) +
or(not(A), B)

are an identity, then:

[example]
equals(implies(A, B), or(not(A), B))

will be valid. Its truth table is:

[cols="6*", options="header"]
|===
| A
| B
| implies(A, B)
| not(A)
| or(not(A)), B)
| equals(implies(A, B), or(not(A), B))

| 1 | 1 | 1 | 0 | 1 | 1
| 0 | 1 | 1 | 1 | 1 | 1
| 1 | 0 | 0 | 0 | 0 | 1
| 0 | 0 | 1 | 1 | 1 | 1
|===

and so indeed we can say that this pair of formulas is an identity. The symbol
for identity is {equiv}, and so we can write the identity as:

implies(A, B) {equiv} or(not(A), B)

The two formulas in an identity can be substituted for each other in other
formulas, without changing the meaning of those other formulas. The commonly
used identities have their own names. The identity that we've just found:

[example]
implies(A, B) {equiv} or(not(A), B)

is called _material implication_.


:numbered!:
==== Questions

. Use the material implication identity to rewrite the following formulas while
  preserving their meaning:
.. implies(A, B)
.. or(not(A), B)
.. implies(A, not(B))
.. or(A, B)


==== Answers

. Use the material implication identity to rewrite the following formulas while
  preserving their meaning:
.. implies(A, B) +
   or(not(A), B)
.. or(not(A), B) +
   implies(A, B)
.. implies(A, not(B)) +
   or(not(A), not(B))
.. or(A, B) +
   implies(not(A), B)


:numbered:
==== Material Equality

Hot on the heels of meeting the Material Implies identity, I encountered the
Material Equality identity:

[example]
equals(P, Q) {equiv} and(or(not(P), Q), or(P, not(Q)))

Actually I found loads of these identities in the Tower, some with names, some
without. I noted down the ones I thought were important, and the ones that had
a pattern to them and skipped over the rest. Is this the right approach?


:numbered!:
==== Questions

. Use the material equality identity to rewrite the following formulas while
  preserving their meaning:
.. equals(P, Q)
.. and(or(not(P), Q), or(P, not(Q)))
.. and(equals(P, Q), P)
.. or(and(or(P, Q), or(not(P), not(Q))), not(P))


==== Answers

. Use the material equality identity to rewrite the following formulas while
  preserving their meaning:
.. equals(P, Q) +
   and(or(not(P), Q), or(P, not(Q)))
.. and(or(not(P), Q), or(P, not(Q))) +
   equals(P, Q)
.. and(equals(P, Q), P) +
   and(and(or(not(P), Q), or(P, not(Q))), P)
.. or(and(or(P, Q), or(not(P), not(Q))), not(P)) +
   or(equals(P, Q), not(P))


:numbered:
=== Commutativity

A special type of identity that some binary functions have is _commutativity_.
The function '`and`' is commutative which means that:

[example]
and(A, B) {equiv} and(B, A)

This identity is called _conjunction commutativity_. Not all
binary functions are commutative though. For example the pair of formulas:

[example]
implies(A, B) +
implies(B, A)

is not and identity because:

[example]
equals(implies(A, B), implies(B, A))

is not a valid formula, and so '`implies`' is not commutative. Here's a table
showing all the binary functions, and whether they're commutative or not, and if
they are, giving the name of the associated identity.

|===
| Binary Function | Commutative? | Name Of Identity

| and             | Yes          | conjunction commutativity
| or              | Yes          | disjunction commutativity
| implies         | No           |
| equals          | Yes          | equality commutativity
|===


:numbered!:
==== Questions

. For each of the four binary functions use a truth table to show if they
  are or are not commutative.

==== Answers

. {empty}
.. '`and`' is commutative if equals(and(A, B), and(B, A)) is valid.
+
|===
| A | B | and(A, B) | and(B, A) | equals(and(A, B), and(B, A))

| 1 | 1 | 1         | 1         | 1
| 0 | 1 | 0         | 0         | 1
| 1 | 0 | 0         | 0         | 1
| 0 | 0 | 0         | 0         | 1
|===
+
so it is valid and so '`and`' is commutative.
.. '`or`' is commutative if equals(or(A, B), or(B, A)) is valid.
+
|===
| A | B | or(A, B) | or(B, A) | equals(or(A, B), or(B, A))

| 1 | 1 | 1          | 1      | 1
| 0 | 1 | 1          | 1      | 1
| 1 | 0 | 1          | 1      | 1
| 0 | 0 | 0          | 0      | 1
|===
+
so it is valid and so '`or`' is commutative.
.. '`implies`' is commutative if equals(implies(A, B), implies(B, A)) is 
   valid.
+
[cols="5*", options="header"]
|===
| A
| B
| implies(A, B)
| implies(B, A)
| equals(implies(A, B), equals(B, A))

| 1 | 1 | 1 | 1 | 1
| 0 | 1 | 1 | 0 | 0
| 1 | 0 | 0 | 1 | 0
| 0 | 0 | 1 | 1 | 1
|===
+
it is not valid and so '`implies`' is not commutative.
.. '`equals`' is commutative if equals(equals(A, B), equals(B, A)) is
   valid.
+
[cols="5*", options="header"]
|===
| A
| B
| equals(A, B)
| equals(B, A)
| equals(equals(A, B), equals(B, A))

| 1 | 1 | 1 | 1 | 1
| 0 | 1 | 0 | 0 | 1
| 1 | 0 | 0 | 0 | 1
| 0 | 0 | 1 | 1 | 1
|===
+
it is valid and so '`equals`' is commutative.


:numbered:
=== Associativity

Another type of identity that some binary functions have is _associativity_. The
'`and`' function is associative, which means:

[example]
and(P, and(Q, R)) {equiv} and(and(P, Q), R)

because the formula:

[example]
equals(and(P, and(Q, R)), and(and(P, Q), R))

is valid. So if you've got three formulas joined by '`and`', it doesn't
make any difference if the first two are joined first, or the last two.
This identity is called _conjunction associativity_. Here's a
table showing all the binary functions, and whether they're associative or
not, and if they are, giving the name of the identity:

|===
| Binary Function | Associative? | Name Of Identity

| and             | Yes          | Conjunction associativity
| or              | Yes          | Disjunction associativity
| implies         | No           |
| equals          | Yes          | Equality associativity
|===


:numbered!:
==== Questions

. For each of the four binary functions use a truth table to show if they
  are or are not associative (big truth tables ahoy!).


==== Answers

. For each of the four binary functions use a truth table to show if they
  are or are not associative (big truth tables ahoy!).
.. '`and`' is associative if equals(and(and(A, B), C), and(A, and(B, C))) is
   valid.
+
[cols="8*", options="header"]
|===
| A
| B
| C
| and(A, B)
| and(and(A, B), C)
| and(B, C)
| and(A, and(B, C))
| equals(and(and(A, B), C), and(A, and(B, C)))

| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
| 0 | 1 | 1 | 0 | 0 | 1 | 0 | 1
| 1 | 0 | 1 | 0 | 0 | 0 | 0 | 1
| 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1
| 1 | 1 | 0 | 1 | 0 | 0 | 0 | 1
| 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1
|===
+
it is valid and so '`and`' is associative.
.. '`or`' is associative if equals(or(or(A, B), C), or(A, or(B, C))) is
   valid.
+
[cols="8*", options="header"]
|===
| A
| B
| C
| or(A, B)
| or(or(A, B), C)
| or(B, C)
| or(A, or(B, C))
| equals(or(or(A, B), C), or(A, or(B, C)))

| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
| 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1
| 1 | 0 | 1 | 1 | 1 | 1 | 1 | 1
| 0 | 0 | 1 | 0 | 1 | 1 | 1 | 1
| 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1
| 0 | 1 | 0 | 1 | 1 | 1 | 1 | 1
| 1 | 0 | 0 | 1 | 1 | 0 | 1 | 1
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1
|===
+
it is valid and so '`or`' is associative.
.. '`implies`' is associative if equals(implies(implies(A, B), C),
   implies(A, implies(B, C))) is valid.
+
[cols="8*", options="header"]
|===
| A
| B
| C
| implies(A, B)
| implies(implies(A, B), C)
| implies(B, C)
| implies(A, implies(B, C))
| equals(implies(implies(A, B), C), implies(A, implies(B, C)))

| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
| 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1
| 1 | 0 | 1 | 0 | 1 | 1 | 1 | 1
| 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1
| 1 | 1 | 0 | 1 | 0 | 0 | 0 | 1
| 0 | 1 | 0 | 1 | 0 | 0 | 1 | 0
| 1 | 0 | 0 | 0 | 1 | 1 | 1 | 1
| 0 | 0 | 0 | 1 | 0 | 1 | 1 | 0
|===
+
it is not valid and so '`implies`' is not associative.
.. '`equals`' is associative if equals(equals(equals(A, B), C),
   equals(A, equals(B, C))) is valid.
+
[cols="8*", options="header"]
|===
| A
| B
| C
| equals(A, B)
| equals(equals(A, B), C)
| equals(B, C)
| equals(A, equals(B, C))
| equals(equals(equals(A, B), C), equals(A, equals(B, C)))

| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
| 0 | 1 | 1 | 0 | 0 | 1 | 0 | 1
| 1 | 0 | 1 | 0 | 0 | 0 | 0 | 1
| 0 | 0 | 1 | 1 | 1 | 0 | 1 | 1
| 1 | 1 | 0 | 1 | 0 | 0 | 0 | 1
| 0 | 1 | 0 | 0 | 1 | 0 | 1 | 1
| 1 | 0 | 0 | 0 | 1 | 1 | 1 | 1
| 0 | 0 | 0 | 1 | 0 | 1 | 0 | 1
|===
+
it is valid and so '`equals`' is associative.


:numbered:
=== Distributivity

Another '`itivity`'. Here are the _distributivity_ identities:

|===
| Identity | Name

| and(A, and(B, C)) {equiv} and(and(A, B), and(A, C))
| Distribution of '`and`' over '`and`'

| and(A, or(B, C)) {equiv} or(and(A, B), and(A, C))
| Distribution of '`and`' over '`or`'

| or(A, and(B, C)) {equiv} and(or(A, B), or(A, C))
| Distribution of '`or`' over '`and`'

| or(A, or(B, C)) {equiv} or(or(A, B), or(A, C))
| Distribution of '`or`' over '`or`'

| implies(A, implies(B, C)) {equiv} implies(implies(A, B), implies(A, C))
| Distribution of '`implies`' over '`implies`'

| implies(A, equals(B, C)) {equiv} equals(implies(A, B), implies(A, C))
| Distribution of '`implies`' over '`equals`'

| or(A, equals(B, C)) {equiv} equals(or(A, B), or(A, C))
| Distribution of '`or`' over '`equals`'
|===

Here's the pattern as I see it. If there are two functions y and z, then if
y distributes over z then:

[example]
y(A, z(B, C)) {equiv} z(y(A, B), y(A, C))


:numbered!:
==== Questions

. For the following distributivity identities use a truth table to show that
  they really are identities.
.. '`and`' over '`and`'
.. '`implies`' over '`equals`'
.. '`or`' over '`equals`'


==== Answers

. For the following distributivity identities use a truth table to show that
  they really are identities.
.. If '`and`' is distributive over '`and`' then: +
   equals(and(P, and(Q, R)), and(and(P, Q), and(P, R))) is valid.
+
[cols="9*", options="header"]
|===
| P
| Q
| R
| and(Q, R)
| and(P, and(Q, R))
| and(P, Q)
| and(P, R)
| and(and(P, Q), and(P, R))
| equals(and(P, and(Q, R)), and(and(P, Q), and(P, R)))

| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
| 0 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1
| 1 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 1
| 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1
| 1 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 1
| 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 1
| 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1
|===
+
the formula is indeed valid, so '`and`' is distributive over '`and`'.
.. '`implies`' over '`equals`'
.. If '`implies`' is distributive over '`equals`' then: +
   equals(implies(P, equals(Q, R)), equals(implies(P, Q), implies(P, R))) +
   is valid.
+
[cols="9*", options="header"]
|===
| P
| Q
| R
| equals(Q, R)
| implies(P, equals(Q, R))
| implies(P, Q)
| implies(P, R)
| equals(implies(P, Q), implies(P, R))
| equals(implies(P, equals(Q, R)), equals(implies(P, Q), implies(P, R)))

| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
| 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
| 1 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 1
| 0 | 0 | 1 | 0 | 1 | 1 | 1 | 1 | 1
| 1 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 1
| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1
| 1 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1
| 0 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1
|===
+
the formula is indeed valid, so '`implies`' is distributive over '`equals`'.
.. If '`or`' is distributive over '`equals`' then: +
   equals(or(P, equals(Q, R)), equals(or(P, Q), or(P, R))) +
   is valid.
+
[cols="9*", options="header"]
|===
| P
| Q
| R
| equals(Q, R)
| or(P, equals(Q, R))
| or(P, Q)
| or(P, R)
| equals(or(P, Q), or(P, R))
| equals(or(P, equals(Q, R)), equals(or(P, Q), or(P, R)))

| 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
| 0 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1
| 1 | 0 | 1 | 0 | 1 | 1 | 1 | 1 | 1
| 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 1
| 1 | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1
| 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 1
| 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1
| 0 | 0 | 0 | 1 | 1 | 0 | 0 | 1 | 1
|===
+
the formula is indeed valid, so '`or`' is distributive over '`equals`'.


:numbered:
=== Idempotence

[[img-benjaminpeirce]]
.http://commons.wikimedia.org/wiki/File:BenjaminPeirce5.jpg#/media/File:BenjaminPeirce5.jpg[Benjamin Peirce] by http://www.pragmaticism.net/faq.htm[www.pragmaticism.net]. Licensed under Public Domain via http://commons.wikimedia.org/wiki/[Wikimedia Commons].
image::benjaminpeirce.jpg[Benjamin Peirce]

'`Hey, Tony`', Benjamin Peirce said as he tapped me on the knee and leaned over
confidentially, '`there's another property of functions that I call
_idempotence_`'. The '`and`' function is idempotent because:

[example]
and(P, P) {equiv} P

and the '`or`' function is idempotent because:

[example]
or(P, P) {equiv} P

but '`implies`' is not idempotent. We can show that '`or`' is idempotent by
showing that:

[example]
equals(or(P, P), P)

is valid, as shown by truth table:

|===
| P | or(P, P) | equals(or(P, P), P)

| 1 | 1        | 1
| 0 | 0        | 1
|===

and '`implies`' is not idempotent because:

[example]
equals(implies(P, P), P)

is not valid, as shown by the truth table:

|===
| P | implies(P, P) | equals(implies(P, P), P)

| 1 | 1             | 1
| 0 | 1             | 0
|===

Here's a table showing whether each function is idempotent or not.

|===
| 0unction        | Idempotent? | Identity Name

| not             | Yes         | Idempotence of negation
| and             | Yes         | Idempotence of conjunction
| or              | Yes         | Idempotence of disjunction
| implies         | No          |
| equals          | No          |
|===

The unary function '`not`' is idempotent because:

[example]
not(not(P)) {equiv} P


:numbered!:
==== Questions

. For the following functions, use a truth table to show whether or not the
  function is idempotent.
.. equals
.. and
. Use the idempotence of negation identity to simplify the following
  formulas:
.. or(P, not(not(Q)))
.. not(not(or(P, Q)))
.. and(not(not(A)), not(not(B)))

==== Answers

. {empty}
.. '`equals`' is not idempotent because: +
   equals(equals(P, P), P) +
   is not valid, as shown by truth table:
+
|===
| P | equals(P, P) | equals(equals(P, P), P)

| 1 | 1            | 1
| 0 | 1            | 0
|===
.. '`and`' is idempotent because: +
   equals(and(P, P), P) +
   is valid, as shown by truth table:
+
|===
| P | and(P, P) | equals(and(P, P), P)

| 1 | 1         | 1
| 0 | 0         | 1
|===
+
. Use the idempotence of negation identity to simplify the following
  formulas:
.. or(P, not(not(Q))) +
   or(P, Q)
.. not(not(or(P, Q))) +
   or(P, Q)
.. and(not(not(A)), not(not(B))) +
   and(A, B)


:numbered:
=== De Morgan's Laws

I found in the Tower that Mathematicians are often good at music too. De Morgan
was a flautist. I've got no musical ability. De Morgan's Laws are a couple of
identities:

[example]
and(A, B) {equiv} not(or(not(A), not(B)))

and:

[example]
or(A, B) {equiv} not(and(not(A), not(B)))

Some say they're obvious. Do you find them obvious? I don't.


:numbered!:
==== Questions

. For De Morgan's laws, use a truth table to show that they are identities.


==== Answers

. For De Morgan's laws, use a truth table to show that they are identities.
.. If: +
   and(A, B) {equiv} not(or(not(A), not(B))) +
   then: +
   equals(and(A, B), not(or(not(A), not(B)))) +
   is valid. The truth table is:
+
[cols="8*", options="header"]
|===
| A
| B
| and(A, B)
| not(A)
| not(B)
| or(not(A), not(B))
| not(or(not(A), not(B)))
| equals(and(A, B), not(or(not(A), not(B))))

| 1 | 1 | 1 | 0 | 0 | 0 | 1 | 1
| 0 | 1 | 0 | 1 | 0 | 1 | 0 | 1
| 1 | 0 | 0 | 0 | 1 | 1 | 0 | 1
| 0 | 0 | 0 | 1 | 1 | 1 | 0 | 1
|===
+
which shows it is valid, and so the two formulas are equivalent.
.. If: +
   or(A, B) {equiv} not(and(not(A), not(B))) +
   then: +
   or(A, B) {bicond} not(and(not(A), not(B)) +
   is valid. The truth table for this formula is:
+
[cols="8*", options="header"]
|===
| A
| B
| or(A, B)
| not(A)
| not(B)
| and(not(A), not(B))
| not(and(not(A), not(B)))
| equals(or(A, B), not(and(not(A), not(B)))) +

| 1 | 1 | 1 | 0 | 0 | 0 | 1 | 1
| 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1
| 1 | 0 | 1 | 0 | 1 | 0 | 1 | 1
| 0 | 0 | 0 | 1 | 1 | 1 | 0 | 1
|===
+
which shows it is valid, and so the pair of formulas we started with is an
identity.


:numbered:
== Sets

[[img-gottlob_frege]]
.http://commons.wikimedia.org/wiki/File:Young_frege.jpg#media/File:Young_frege.jpg[Gottlob Frege] Licensed under Public Domain via http://commons.wikimedia.org/wiki/[Wikimedia Commons].
image::gottlob_frege.jpg[Gottlob Frege]

'`Tony`', '`Yes Professor Frege?`', '`You should really start with _sets_`',
'`Okay, whatevs Prof`'.

=== What's A Set?

A _set_ is a collection of distinct _elements_, where there's no order, and
duplicates aren't allowed. Some example are:

* Primary colours.
* Even integers
* Letters of the alphabet.
* Natural numbers.

Written out in _set notation_, these look like:

* {red, green, blue}
* {..., -4, -2, 0, 2, 4, ...}
* {a, b, c, ..., x, y, z}
* {0, 1, 2, 3, ...}

When the set includes an elipsis (...) at one end or both, it denotes an
infinite series. An ellipsis in the middle of a set of elements is used to
save writing out all the items of an obvious set.

Strangely enough, a set with a finite number of elements is a _finite set_
and a set with an infinite number of elements is an _infinite set_.

:numbered:
=== Identity

If two sets have exactly the same elements in them, then they form an
_identity_. In set notation, if sets A and B are and identity they write:

[example]
A {equiv} B

if A and B aren't an identity they write:

[example]
A {nequiv} B

Let's say we've got two sets S and T:

[example]
S is {1, 2} +
T is {2, 1}

S and T are an identity because all that matters for identity is that the two
sets have the same elements in them. So we can write:

[example]
S {equiv} T

Let's make up two sets A and B:

[example]
A is {1, 2, 2} +
B is {1, 2}

Sets don't have any duplicates so the two sets A and B are an identity
and we can write:

[example]
A {equiv} B

'`Hey, you said that sets can't have duplicates, but then you wrote `{1, 2, 2}`.
What gives?`'. When you write `{1, 2, 2}`, you're describing a
set with two elements, `1` and `2`. So `{1, 2, 2}` {equiv} `{1, 2}`. So these
are two ways of describing the same set. '`Well, okay I suppose. I have to say
I'm not entirely convinced, but carry on for now`'.



=== Common Sets Of Numbers

Some sets of numbers are common enough to have their own names and symbols:

[cols="3*", options="header"]
|===
| Name | Symbol | Definition

| Real Numbers
| *R*
| All the numbers on a continuous line from negative infinity to positive
infinity.

| Integers
| *Z*
| {..., -2, -1, 0, 1, 2, ...}

| Natural Numbers
| *N*
| {0, 1, 2, ...}

| Positive Integers
| *Z+*
| {1, 2, 3, ...}

| Boolean Values
| *B*
| {1, 0} +
By convention, 1 is interpreted as true, and 0 as false.

| Empty Set
|
| {}
|===


=== Russell's Paradox

On your first day as an assistant librarian, you're asked to compile a book
that is a catalogue of all of the books in the library that don't mention
themselves. Eventually you present the chief librarian with your completed
catalogue. The chief librarian asks, '`Does the catalogue mention the
catalogue?`'. Well no, you answer...but then if the catalogue doesn't mention
itself, then it should be in the catalogue, in which case it shouldn't...

You've become a victim of Russell's Paradox, and you're fired. Lol!

In terms of sets, Russell's Paradox is asking, what's the set of all sets that
don't have themselves as an element? That set doesn't exist.

So, that's solved it in maths language, but how should you have answered the
chief librarian? Well, you should say that the book (set) he's asked for can't
exist. But you can write a book (set), which has the same
contents as has been requested, except that it doesn't contain itself.


=== Other Paradoxes

Curry's Paradox is:

[example]
If this sentence is true, then you owe me a million pounds.

Do you owe me a million pounds then? Anyway, they told me that there's an
equivalent paradox for sets.

They also told me that there's a paradox with the set of all sets, so that
doesn't exist either. As it seems to me, a paradox is something that is clearly
incorrect, but you can't see the flaw in the argument. Of course, all paradoxes
can be resolved, and the resolution deepens one's understanding. '`Ooh, hark at
him pontificating on the philosophy of it all!!`'. Okay, okay.


=== Tuples

'`Wait, you say that with sets, ordering doesn't matter, but in lots of
things ordering _does_ matter. What about a list of countries in alphabetical
order?`'

Yes, good point reader. Remember I'm still learning this stuff too, you know.
I'll get back to you...

...I'm back, got it all worked out. Here's our set of countries:

[example]
{'`UK`', '`Germany`', '`Spain`'}

Now adding alphabetical ordering:

[example]
{{'`UK`', 3}, {'`Germany`', 1}, {'`Spain`', 2}}

So we've made a set of sets. The inner sets have the country and their position
in the alphabetical order. Ordered sets occur quite often in maths, so they're
given the name _tuples_ and denoted by surrounding the elements with brackets,
so:

[example]
{{'`UK`', 3}, {'`Germany`', 1}, {'`Spain`', 2}} {equiv}
('Germany', '`Spain`', '`UK`')

Here are the names of tuples based on the number of elements they contain...

|===
| Number Of Elements | Name   | Example

| 0                  | Nuple  | ()
| 1                  | Single | (8)
| 2                  | Double | (7, 4)
| 3                  | Triple | ('`bear`', '`tiger`', '`sheep`')
|===

Actually, I made up '`nuple`'. It's commonly called '`the empty tuple`'.


=== Functions

In the tower they fiddle around a lot with functions. A function is a set
that relates a set of tuples (the _domain_) to another set (the _codomain_).
For any tuple (called the '`input`') of the domain there's a double in the
function of the form:

[example]
(input, output)

where '`output`' is an element of the _codomain_.

'`That sounds all very clever and fancy, but what do you actually mean?`' Well
an example I found in the tower is the `add_one` function which has as its
domain *Z*^1^:

[example]
*Z*^1^ {equiv} {..., (-2), (-1), (0), (1), (2), ...}

The codomain of `add_one` is *Z*, and the relationship is:

[example]
add_one {equiv} {..., ( (-2), -1), ( (-1), 0), ( (0), 1), ( (1), 2), ...}

and if you want to talk about individual inputs and outputs of a function, you
can write:

[example]
add_one(-2) {equiv} -1 +
add_one(70) {equiv} 71 +
add_one(4002) {equiv} 4003 +

We've defined the function `add_one` in words and through examples and using
the ellipses (and the clue is in the name of the function!) but I saw that
mostly, mathematicians will define a function using mathematical notation, so
they'll write:

[example]
add_one(x) {equiv} x + 1

They'll often use the letter `x`, but it needn't be. Could be anything. Eg:

[example]
add_one(H) {equiv} H + 1

Another example. Let's make up another function called `mult_ten`. The domain
will be *Z*^1^ and the codomain *Z* as in the previous example. The relationship
is defined as:

[example]
mult_ten(x) {equiv} x * 10

Let's try it out with some inputs and see what the outputs are:

[example]
mult_ten(1) {equiv} 10 +
mult_ten(8) {equiv} 80 +
mult_ten(0) {equiv} 0 +

In the previous examples we chose domains of singles, but let's create a
function that has a domain of doubles. So let's create a function called
`mult_add` with the domain *Z*^2^. Now *Z*^2^ is the set of doubles which are
all possible combinations of an element of *Z* followed by another element of
*Z* which is shown in this table:

[cols="8*", options="header"]
|===
|
| ...
| -2
| -1
| 0
| 1
| 2
| ...

| ...
| (..., ...)
| (..., -2)
| (..., -1)
| (..., 0)
| (..., 1)
| (..., 2)
| (..., ...)

| -2
| (-2, ...)
| (-2, -2)
| (-2, -1)
| (-2, 0)
| (-2, 1)
| (-2, 2)
| (-2, ...)

| -1
| (-1, ...)
| (-1, -2)
| (-1, -1)
| (-1, 0)
| (-1, 1)
| (-1, 2)
| (-1, ...)

| 0 
| (0, ...)
| (0, -2)
| (0, -1)
| (0, 0)
| (0, 1)
| (0, 2)
| (0, ...)

| 1 
| (1, ...)
| (1, -2)
| (1, -1)
| (1, 0)
| (1, 1)
| (1, 2)
| (1, ...)

| 2 
| (2, ...)
| (2, -2)
| (2, -1)
| (2, 0)
| (2, 1)
| (2, 2)
| (2, ...)

| ... 
| (..., ...)
| (..., -2)
| (..., -1)
| (..., 0)
| (..., 1)
| (..., 2)
| (..., ...)
|===

The codomain of `mult_add` is *Z*, and the relationship between the domain and
codomain is defined by:

[example]
mult_add(x, y) {equiv} x * 2 + y

Let's try it out with some inputs and see what the outputs are:

[example]
mult_add(1, 6) {equiv} 8 +
mult_add(8, 3) {equiv} 19 +
mult_add(0, 2) {equiv} 2 +

Functions whose input is a single are called _unary_ functions, and functions
whose input is a double are called _binary_ functions. Can we have functions
whose input is the nuple?

[[img-obama]]
image::obama.jpg[Yes we can!]

Let's define a function called `five`, it'll have the domain {()} and the
codomain *Z*. The function just contains one double:

[example]
( (), 5)

so:

[example]
five() {equiv} 5

=== Direct Product

The 


=== Is In

Set theoreticians use the symbol {isin} to mean '`is an element of`'. So if
there was an element `x` that was in a set `A` we could abbreviate that to:

[example]
x {isin} A

Conversely, they use the symbol {notin} to mean '`is not an element of`'. Eg.

[example]
x {notin} A


=== Indicator Function

Those wacky mathematicians have come up with a binary function called the
_indicator function_, denoted by *1*, that has as its input a double consisting
of an element and a set. The function is defined as:

* Domain: The set of doubles of all possible combinations of (element, set).
* Codomain: *B*
* *1*(x, A) {equiv} true if x {isin} A otherwise false

[example]
*1*(1, *Z*) {equiv} true +
*1*('France', *Z*) {equiv} false +
*1*(-1000, {red, green, blue}) {equiv} false +


=== Subset

Another binary function with codomain *B* is the subset function that has the
symbol {sube}. The subset function is defined as:

* Domain: The set of doubles of all possible combination of (set, set)
* Codomain: *B*
* {sube}(A, B) {equiv} true if and only if all the elements of A are also in B,
otherwise false.

So if A is a subset of B we can write:

[example]
{sube}(A, B) {equiv} true

Following this definition of a subset, every set is a subset of itself. So it's
always true that:

[example]
{sube}(A, A) {equiv} true

By the way, the domain of {sube} crops up quite a lot in definitions of
functions, so I'll give it the name *S*, so from now on:

[example]
*S* {equiv} The set of doubles of all possible combination of (set, set)


=== Equals

The symbol for the _equals_ function is `=`, and it's defined as:

* Domain: *S*
* Codomain: *B*
* =(A, B) {equiv} true if A and B form an identiy, otherwise false.


=== Proper Subset

The symbol for the _proper subset_ function is `{sube}`, and it's defined as:

* Domain: *S*
* Codomain: *B*
* {sub}(A, B) {equiv} true if `{sube}(A, B)` is true and A {nequiv} B.


=== Union

[example]
{cup}: *S* {rarr} *S* +
A, B {brarr} {x | x {isin} A or x {isin} B}


=== Intersection

[example]
{cap}: *S* {rarr} *S* +
A, B {brarr} {x | x {isin} A and x {isin} B}


=== Complement

[example]
\\: *S* {rarr} *S* +
A, B {brarr} {x | x {isin} A and x {notin} B}

=== Universal Class








:numbered!:
==== Questions

. Write the following sets in set notation:
.. Prime numbers less than 12. +
   {2, 3, 5, 7, 11}
. For the sets in question 1, say whether they are finite or infinite.
.. {2, 3, 5, 7, 11} +
   Finite.
. Say whether the following are valid sets or not:
.. {1, 2, 3, 2, 1} +
   No, because the 1 and 2 are repeated.

==== Answers

Rs

=== Rosetta Stone

Rs

==== Synonyms

Rs

[cols="2*", options="header"]
|===
| Name
| Synonym

| Empty set, {}
| &#x2205;

| Double
| Ordered pair
|===


=== Sources

* http://www.mathsisfun.com/sets/sets-introduction.html
* http://people.cs.pitt.edu/~milos/courses/cs441/lectures/Class7.pdf
* http://www.wtamu.edu/academic/anns/mps/math/mathlab/int_algebra/int_alg_tut3_sets.htm



:numbered:
== Boolean Algebra II

In which we encounter entailment and SAT problems!

:numbered:
=== Entailment

'`What does that _entail_, lol!`', yeah thanks for that. In English you might
have some _premises_ leading to a _conclusion_ such as:

[example]
Abelard ordered coffee or Abelard ordered cake. Abelard didn't order cake.
Therefore Abelard ordered coffee.

To convert the premises and conclusion from English into logical formulas, we
first of all define the atomic formulas:

[example]
A: Abelard ordered coffee. +
B: Abelard ordered cake.

So the premises and conclusion becomes:

[example]
Premises: or(A, B), not(B) +
Conclusion: A

Now, do the premises _entail_ the conclusion? In other words, for every
interpretation where the premises are true, is the conclusion true? If the
premises entail the conclusion, the following formula must be valid:

[example]
implies(and(or(A, B), not(B)), A)

In effect we've joined the premises together with '`and`' and then added on the
conclusion with an '`implies`' to get the formula. Bring on the table of truth!

[cols="6*", options="header"]
|===

| A
| B
| or(A, B)
| not(B)
| and(or(A, B), not(B))
| implies(and(or(A, B), not(B)), A)

| 1 | 1 | 1 | 0 | 0 | 1
| 0 | 1 | 1 | 0 | 0 | 1
| 1 | 0 | 1 | 1 | 1 | 1
| 0 | 0 | 0 | 1 | 0 | 1
|===

The last column is always true, so the formula is valid, so the premises do
entail the conclusion. Logicians denote an entailment with the {entails} symbol.
So the entailment we've just found can be written:

[example]
or(A, B), not(B) {entails} A

Here's another example of some premises and a conclusion in English:

[example]
If we run out of petrol we won't get to the wedding on time. If we lose our
way we won't get to the wedding on time. We've run out of petrol. We won't get
to the wedding on time.

In logic symbols the argument is:

[example]
A: Run out of petrol. +
B: Get to the wedding on time. +
C: Lose our way. +
Premises: implies(A, not(B)), implies(C, not(B)), A +
Conclusion: not(B)

It's an entailment if:

[example]
implies(and(and(implies(A, not(B)), implies(C, not(B))), A), not(B))

is valid. Doing a giant truth table:

[cols="9*", options="header"]
|===
| A
| B
| C
| not(B)
| implies(A, not(B))
| implies(C, not(B))
| and(implies(A, not(B)), implies(C, not(B)))
| and(and(implies(A, not(B)), implies(C, not(B))), A)
| implies(and(and(implies(A, not(B)), implies(C, not(B))), A), not(B))

| 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 | 1
| 0 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 1
| 1 | 0 | 1 | 1 | 1 | 0 | 0 | 0 | 1
| 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1
| 1 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 1
| 0 | 1 | 0 | 0 | 1 | 1 | 1 | 0 | 1
| 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 1
| 0 | 0 | 0 | 1 | 1 | 1 | 1 | 0 | 1
|===

Shows that the formula is valid and so we can write that:

[example]
implies(A, not(B)), implies(C, not(B)), A {entails} not(B)


:numbered!:
==== Questions

. Construct logical formulas for the following premises and conclusions:
.. If it's a silent film then there's no sound. It's a silent film. Therefore
   there's no sound.
.. Scheherazade bought black paint or Scheherazade bought grey paint.
   Scheherazade did not buy grey paint. Therefore Scheherazade bought black
   paint.
.. It is not the case that Ben won a tennis match and Toby won a tennis match.
   Toby won a tennis match. Therefore Ben did not win a tennis match.
.. Bill orders 6x or Bill orders Tribute. If Bill orders 6x or Tribute then the
   pub is open. Bill does not order Tribute. Therefore the pub is open and Bill
   orders 6x.
.. The light switch is on or the light switch is off. The light switch is not on
   and off. This light switch is not on. Therefore the light switch is off.
. For the arguments given in question 1, show whether they are valid or not.


==== Answers

. Construct logical formulas for the following premises and conclusions:
.. If it's a silent film then there's no sound. It's a silent film. Therefore
   there's no sound. +
   P: It's a silent film. +
   Q: There's no sound. +
   Premises: implies(P, Q), P +
   Conclusion: Q
.. A: Scheherazade bought black paint. +
   B: Scheherazade bought grey paint. +
   Premises: or(A, B), not(B) +
   Conclusion: A
.. P: Ben won a tennis match. +
   Q: Toby won a tennis match. +
   Premises: not(and(P, Q)), Q
   Conclusion: not(P)
.. P: Bill orders 6x. +
   Q: Bill orders Tribute. +
   R: The pub is open. +
   Premises: or(P, Q), implies(or(P, Q), R), not(Q)
   Conclusion: and(R, P)
.. P: The light switch is on. +
   Q: The light switch is off. +
   Premises: or(P, Q), not(and(P, Q)), not(P)
   Conclusion: Q
. For the premises and conclusions given in question 1, show whether they are
  entailments not.
.. Premises: implies(P, Q), P +
   Conclusion: Q +
   The truth table below shows that the formula
   implies(and(implies(P, Q), P), Q) is valid, and so +
   implies(P, Q), P {entails} Q
+
[cols="5*", options="header"]
|===
| P
| Q
| implies(P, Q)
| and(implies(P, Q), P)
| implies(and(implies(P, Q), P), Q)

| 1 | 1 | 1 | 1 | 1
| 0 | 1 | 1 | 0 | 1
| 1 | 0 | 0 | 0 | 1
| 0 | 0 | 1 | 0 | 1
|===
+
.. Premises: or(A, B), not(B) +
   Conclusion: A +
   The truth table below shows that the formula
   implies(and(or(A, B), not(B)), A) is valid, and so: +
   or(A, B), not(B) {entails} A
+
[cols="6*", options="header"]
|===
| A
| B
| or(A, B)
| not(B)
| and(or(A, B), not(B))
| implies(and(or(A, B), not(B)), A)

| 1 | 1 | 1 | 0 | 0 | 1
| 0 | 1 | 1 | 0 | 0 | 1
| 1 | 0 | 1 | 1 | 1 | 1
| 0 | 0 | 0 | 1 | 0 | 1
|===
+
.. Premises: not(and(P, Q)), Q +
   Conclusion: not(P) +
   The truth table below shows that the formula: +
   implies(and(or(P, Q), Q), not(P)) +
   is not valid and so the premises do not ential the conclusion.
+
|===
| P | Q | or(P, Q) | and(or(P, Q), Q) | not(P) | implies(and(or(P, Q)), not(P))

| 1 | 1 | 1        | 1                | 0      | 0
| 0 | 1 | 1        | 1                | 1      | 1
| 1 | 0 | 1        | 0                | 0      | 1
| 0 | 0 | 0        | 0                | 1      | 1
|===
+
.. Premises: or(P, Q), implies(or(P, Q), R), not(Q) +
   Conclusion: and(R, P) +
   The truth table below shows that the formula: +
   implies(and(and(or(P, Q), implies(or(P, Q), R)), not(Q)), and(R, P)) +
   is valid and so: +
   or(P, Q), implies(or(P, Q), R), not(Q) {entails} and(R, P)
+
[cols="10*", options="header"]
|===
| P
| Q
| R
| or(P, Q)
| implies(or(P, Q), R)
| not(Q)
| and(or(P, Q), implies(or(P, Q), R))
| and(and(or(P, Q), implies(or(P, Q), R)), not(Q))
| and(R, P)
| implies(and(and(or(P, Q), implies(or(P, Q), R)), not(Q)), and(R, P))

| 1 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 0 | 1
| 0 | 1 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 1
| 1 | 0 | 1 | 0 | 0 | 1 | 1 | 0 | 0 | 1
| 0 | 0 | 1 | 0 | 1 | 0 | 1 | 0 | 0 | 1
| 1 | 1 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 1
| 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 1
| 1 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 1
| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 | 1
|===
+
.. Premises: or(P, Q), not(and(P, Q)), not(P)
   Conclusion: Q
   The truth table below shows that the formula: +
   implies(and(and(or(P, Q), not(and(P, Q))), not(P)), Q) +
   is valid and so: +
   or(P, Q), not(and(P, Q)), not(P) {entails} Q +
+
[cols="9*", options="header"]
|===
| P
| Q
| or(P, Q)
| and(P, Q)
| not(and(P, Q))
| and(or(P, Q), not(and(P, Q)))
| not(P)
| and(and(or(P, Q), not(and(P, Q))), not(P))
| implies(and(and(or(P, Q), not(and(P, Q))), not(P)), Q)

| 1 | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 1
| 0 | 1 | 1 | 0 | 1 | 1 | 1 | 1 | 1
| 1 | 0 | 1 | 0 | 1 | 1 | 0 | 0 | 1
| 0 | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 1
|===




:numbered:
=== Unsatisfiability Theorem

I would like, dear reader, to present to you a mathematical theorem. '`Oooh,
hark at him with his theorems! He's just got started in maths and now he thinks
he's Bertrand Russell!`'. Well, okay reader maybe I was being a bit pompous, but
anyway I found that a theorem is a statement about maths that's been proven to
be true. The _Unsatisfiability Theorem_ states that:

[example]
and(and(A, B), C) {entails} P if and only if and(and(and(A, B) C) not(P)) is unsatisfiable.

So what's the proof of that? Well, if an interpretation satisfies {A, B, C},
then it must satisfy P, and therefore it can't satisfy not(P). So for every
interpretation, {A, B, C, not(P)} is unsatisfiable.

I found that I had to think about that for quite a long time before I accepted
it to be true. So what's a proof exactly? It's a chain of small self-evidently
true steps that lead to the theorem.







:numbered!:
==== Questions

. Write the following formulas in CNF notation:
.. or(A, implies(not(B), A))
.. implies(implies(A, B), C)
.. or(P, equals(Q, not(P)))
.. or(and(A, B), and(A, C))
.. and(and(A, B), and(A, C))


==== Answers

. {empty}
.. or(A, implies(not(B), A)) +
   or(A, or(not(not(B)), A)) [Material Implication] +
   or(A, or(B, A)) [Idempotence of '`not`'] +
   or(or(A, B), A) [Associativity of '`or`']
.. implies(implies(A, B), C) +
   implies(or(not(A), B), C) [Material Implication] +
   or(not(or(not(A), B)), C) [Material Implication] +
   or(and(not(not(A), not(B)), C) [De Morgan's Laws] +
   or(and(A, not(B)), C) [Idempotence of '`not`'] +
   and(or(C, A), or(C, not(B))) [Distribute '`or`' over '`and`']
.. or(P, equals(Q, not(P))) +
   or(P, and(or(not(Q), not(P)), or(Q, not(not(P))))) [Material Equality] +
   or(P, and(or(not(Q), not(P)), or(Q, P))) [Idempotence of '`not`'] +
   and(or(P, or(not(Q), not(P))), or(P, or(Q, P))) [Distribute '`or`' over
   '`and`']
.. or(and(A, B), and(A, C)) +
   and(or(and(A, B), A), or(and(A, B), C)) [Distribute '`or`' over '`and`'] +
   and(and(or(A, A), or(B, A)), and(or(A, C), or(B, C))) [Distribute '`or`' over
   '`and`'] +
   and(and(and(or(A, A), or(B, A)), or(A, C)), or(B, C)) ['`and`' is
   associative]
.. and(and(A, B), and(A, C)) +
   and(and(and(A, B), A), C) ['`and`' is associative]


:numbered:
=== Conjunctive Normal Form (CNF)

When I got to this point in the Ivory Tower, John Alan Robinson took me by the
scruff of the neck and said, '`Look, you've just got to learn this, don't ask
why`'. '`Okay, I replied meekly`'.

A _literal_ is an atomic formula or the '`not`' of an atomic formula. Eg:

[example]
P +
not(P)

A _clause_ is a number of literals joined by the '`or`' function. Eg:

[example]
or(not(P), Q) +
P +
or(or(P, Q), not\(R))

A formula in CNF is a number of clauses joined by the '`and`' function. Eg:

and(and(or(not(P), Q), P), or(or(P, Q), not\(R)))

Anyway, John Alan Robinson went on to tell me the most remarkable thing, _any_
formula can be written in CNF. You simply (!) use the following identities
(which we've previously encountered), applying them in the given order:

[cols="3"]
|===
.2+| Step 1: Implications
| Material Implication
| implies(P, Q) {equiv} or(not(P), Q)

| Material Equivalence
| equals(P, Q) {equiv} and(or(not(P), Q), or(P, not(Q)))

.2+| Step 2: Negations
| Idempotence of '`not`'
| not(not(P)) {equiv} P

| De Morgan's Laws
| and(A, B) {equiv} not(or(not(A), not(B))) +
  or(A, B) {equiv} not(and(not(A), not(B)))

.4+| Step 3: Distributivity
| '`and`' over '`and`'
| and(A, and(B, C)) {equiv} and(and(A, B), and(A, C))

| '`and`' over '`or`'
| and(A, or(B, C)) {equiv} or(and(A, B), and(A, C))

| '`or`' over '`and`'
| or(A, and(B, C)) {equiv} and(or(A, B), or(A, C))

| '`or`' over '`or`'
| or(A, or(B, C)) {equiv} or(or(A, B), or(A, C))

.2+| Step 4: Associativity
| '`and`'
| and(A, and(B, C)) {equiv} and(and(A, B), C)

| '`or`'
| or(A, or(B, C)) {equiv} or(or(A, B), C)
|===

Here's are a couple of examples that I was shown. We start out with an example
formula in the normal logical notation:

[example]
implies(and(A, not(B)), implies(C, B))

Applying step 1, Material Implication, we get:

[example]
implies(and(A, not(B)), or(not\(C), B))

applying Material Implication again gives us:

[example]
or(not(and(A, not(B))), or(not\(C), B))

so now we've got rid of the '`implies`' functions. Now let's plough on with
step 2, Negations, where the application of De Morgan's Laws, gives:

[example]
or(or(not(A), not(not(B))), or(not\(C), B))

Idempotence of '`not`' alert!

[example]
or(or(not(A), B), or(not\(C), B))

We're so nearly in CNF, but not quite. Since '`or`' is associative:

[example]
or(or(or(not(A), B), not\(C)), B)

Hah! We're now in CNF. Okay, in the second example we've got to convert:

[example]
or(equals(A, B), not\(C))

into CNF. Starting with step 1, Implications:

[example]
or(and(or(not(A), B), or(A, not(B))), not\(C))

there aren't any negations to do, so skipping on to step 3, distributivity:

[example]
and(or(not\(C), or(not(A), B)), or(not\(C), or(A, not(B))))

using the associativity of {or}:

[example]
and(or(or(not\(C), not(A)), B), or(or(not\(C), A), not(B)))

we've got it in CNF.


:numbered!:
==== Questions

. Write the following formulas in CNF notation:
.. or(A, implies(not(B), A))
.. implies(implies(A, B), C)
.. or(P, equals(Q, not(P)))
.. or(and(A, B), and(A, C))
.. and(and(A, B), and(A, C))


==== Answers

. {empty}
.. or(A, implies(not(B), A)) +
   or(A, or(not(not(B)), A)) [Material Implication] +
   or(A, or(B, A)) [Idempotence of '`not`'] +
   or(or(A, B), A) [Associativity of '`or`']
.. implies(implies(A, B), C) +
   implies(or(not(A), B), C) [Material Implication] +
   or(not(or(not(A), B)), C) [Material Implication] +
   or(and(not(not(A), not(B)), C) [De Morgan's Laws] +
   or(and(A, not(B)), C) [Idempotence of '`not`'] +
   and(or(C, A), or(C, not(B))) [Distribute '`or`' over '`and`']
.. or(P, equals(Q, not(P))) +
   or(P, and(or(not(Q), not(P)), or(Q, not(not(P))))) [Material Equality] +
   or(P, and(or(not(Q), not(P)), or(Q, P))) [Idempotence of '`not`'] +
   and(or(P, or(not(Q), not(P))), or(P, or(Q, P))) [Distribute '`or`' over
   '`and`']
.. or(and(A, B), and(A, C)) +
   and(or(and(A, B), A), or(and(A, B), C)) [Distribute '`or`' over '`and`'] +
   and(and(or(A, A), or(B, A)), and(or(A, C), or(B, C))) [Distribute '`or`' over
   '`and`'] +
   and(and(and(or(A, A), or(B, A)), or(A, C)), or(B, C)) ['`and`' is
   associative]
.. and(and(A, B), and(A, C)) +
   and(and(and(A, B), A), C) ['`and`' is associative]


:numbered:
=== CNF Set Notation

As we've seen, the '`or`' function is commutative and associative. Dr Robinson
told me that this means that for any CNF clause it doesn't matter how you
arrange the brackets and literals, each arrangement will be equivalent. Let's
try that out:

[example]
or(A, B) +
or(B, A)

well yes, that's easy because since '`or`' is commutative:

[example]
or(A, B) {equiv} or(B, A)

Here are all the different ways of arranging three literals:

[example]
or(or(A, B), C) +
or(or(A, C), B) +
or(or(B, A), C) +
or(or(B, C), A) +
or(or(C, A), B) +
or(or(C, B), A) +
or(A, or(B, C)) +
or(A, or(C, B)) +
or(B, or(A, C)) +
or(B, or(C, A)) +
or(C, or(A, B)) +
or(C, or(B, A))

I'll try and transform the second clause to be the same as the first:

[example]
or(or(A, C), B) +
or(A, or(C, B)) [associativity] +
or(A, or(B, C)) [commutativity] +
or(or(A, B), C) [associativity] +

and transforming the third clause to be the same as the first:

[example]
or(or(B, A), C) +
or(or(A, B), C) [commutativity]

Okay, so a collection of literals in any order is enough to specify a clause.
'`But wait`', cries Robinson, '`there's more! Since AND is commutative and
associative, all ways of arranging the clauses and brackets of a CNF formula
are equivalent`'. Well let's try that out with two clauses A and B:

[example]
and(A, B) +
and(B, A)

since '`and`' is commutative:

[example]
and(A, B) {equiv} and(B, A)

Here are all the different ways of arranging three clauses:

[example]
and(and(A, B), C) +
and(and(A, C), B) +
and(and(B, A), C) +
and(and(B, C), A) +
and(and(C, A), B) +
and(and(C, B), A) +
and(A, and(B, C)) +
and(A, and(C, B)) +
and(B, and(A, C)) +
and(B, and(C, A)) +
and(C, and(A, B)) +
and(C, and(B, A))

I'll try and transform the second formula to be the same as the first:

[example]
and(and(A, C), B) +
and(A, and(C, B)) [associativity] +
and(A, and(B, C)) [commutativity] +
and(and(A, B), C) [associativity] +

and then transform the third formula to be the same as the first:

[example]
and(and(B, A), C) +
and(and(A, B), C) [commutativity]

With that under my belt, Robinson exclaimed, '`Idempotence! We can ignore any
repeated literals in a CNF clause or repeated clauses in a CNF formula`'.
Robinson was used to quicker minds than mine, so I asked him to elaborate. If
we've got a clause:

[example]
or(A, A)

then since '`or`' is idempotent we can replace it with:

[example]
A

and with a more complicated example:

[example]
or(or(A, B), A)

since we know that we can put the brackets and literals anywhere we can write:

[example]
or(or(A, A), B) +
or(A, B) [idempotence]

Likewise, if we've got a CNF formula:

[example]
and(A, A)

them since '`and`' is idempotent we can replace it with:

[example]
A

and with a more complicated example:

[example]
and(and(A, B), A)

since we know that we can put the brackets and literals anywhere we can write:

[example]
and(and(A, A), B) +
and(A, B) [idempotence]

'`Do keep up Locke! I now want to introduce the idea of a _set_, which is a
collection of items which is unordered and no item is repeated. A
CNF clause can be written as a set of literals, and a CNF formual can be written
as a set of clauses`'. 

Here are some example clauses in the left hand column, and the clauses in set
notation in the right hand column:

|===
| CNF Clause           | Set Notation

| or(not(P), Q)        | {not(P), Q}
| P                    | \{P}
| or(or(P, Q), not\(R)) | {P, Q, not\(R)}
|===

So an example formula:

and(and(or(not(P), Q), P), or(or(P, Q), not\(R)))

is written in CNF set notation as:

{{not(P), Q}, \{P}, {P, Q, not\(R)}}

Yes, I like this CNF set notation. Much clearer and easier to write. How do you
find it? Here's another example:

[example]
or(or(not(A), B), not\(C))

which written in set notation is:

[example]
{{not(A), B, not\(C)}}

Okay, in the second example we've got to convert:

[example]
and(or(or(not\(C), not(A)), B), or(or(not\(C), A), not(B)))

into set notation which gives:

[example]
{{not\(C), not(A), B}, {not\(C), A, not(B)}}

So to go from CNF to CNF set notation:

. Remove repeated literals in clauses ('`or`' associativity, commutativity and
  idempotence)
. Remove repeated clauses in the formula ('`and`' associativity, commutativity
   and idempotence)
. Rewrite clauses as a comma separated list of literals surrounded by braces.
. Rewrite formula as comma separated list of clauses surrounded by braces.


:numbered!:
==== Questions

. Write the answers to the CNF section in CNF set notation:


==== Answers

. {empty}
.. and(or(C, A), or(C, not(B))) +
   {{C, A}, {C, not(B)}}
.. and(or(P, or(not(Q), not(P))), or(P, or(Q, P))) +
   and(or(P, or(not(Q), not(P))), or(P, Q)) ['`or`' associativity,
   commutativity and idempotence] +
   {{P, not(Q), not(P)}, {P, Q}} [set notation]
.. and(and(and(or(A, A), or(B, A)), or(A, C)), or(B, C)) +
   {\{A}, {B, A}, {A, C}, {B, C}} [set notation]
.. and(and(and(A, B), A), C) +
   and(and(B, A), C) ['`and`' associativity, commutativity and idempotence] +
   {\{B}, \{A}, \{C}} [Set notation]


:numbered:
=== Propositional Resolution

The logicians have discovered / invented other ways of showing if an argument is
valid or not. One of these methods is _Propositional Resolution_. 





Writing out truth tables gets tedious, especially as the number of rows grows
exponentially with the number of atomic formulas. The logicians have discovered

:numbered:
=== Mendelson's Axiomatic System

Writing out truth tables gets tedious, especially as the number of rows grows
exponentially with the number of atomic formulas. The logicians have discovered
/ invented other ways of showing if an argument is valid or not. One of these
methods is _Mendelson's Axiomatic System_. They tell me it may not be easier
than truth tables but enables them to introduce Big Ideas. I can't help but
feel that's somewhat patronising. These so-called Big Ideas better be worth it.
Mendelson's System only works if an argument is expressed using only the
functions {not} and {implies}. You have to rewrite the argument using the
following rules of replacement:

* (P {or} Q) {equiv} ({not}P {implies} Q)
* (P {and} Q) {equiv} {not}(P {implies} {not}Q)
* (P {bicond} Q) {equiv} {not}((P {implies} Q) {implies} {not}(Q {implies} P))

So for example we looked at this argument previously:

[example]
(A {or} B), {not}B {entails} A

Using the above rules of replacement we can rewrite it as:

[example]
({not}A {implies} B), {not}B {entails} A



about theseSo, I'll press on

and I find this attitude
somewhat patronising. It involves rewriting the assumptions in a progressively simpler and simpler form until you
end up with the conclusion. The simplifying substitutions are valid arguments
that are known as _rules of inference_. One rule of inference is:

[example]
(A {or} B), {not}B {entails} A

Writing out truth tables gets tedious, especially as the number of rows grows
exponentially with the number of atomic formulas. The logicians have discovered
/ invented an easier way of showing if an argument is valid or not. It involves rewriting the assumptions in a progressively simpler and simpler form until you
end up with the conclusion. The simplifying substitutions are valid arguments
that are known as _rules of inference_. One rule of inference is:


:numbered:
=== Rules Of Inference

Writing out truth tables gets tedious, especially as the number of rows grows
exponentially with the number of atomic formulas. The logicians have discovered
/ invented an easier way of showing if an argument is valid or not. It involves rewriting the assumptions in a progressively simpler and simpler form until you
end up with the conclusion. The simplifying substitutions are valid arguments
that are known as _rules of inference_. One rule of inference is:

[example]
P, P {implies} Q {entails} Q

You can see this is a valid argument because the formula:

[example]
\((P {and} (P {implies} Q)) {implies} Q)

has the truth table:

[cols="5"]
|===
| P
| Q
| (P {implies} Q)
| (P {and} (P {implies} Q))
| \((P {and} (P {implies} Q)) {implies} Q)

| 1 | 1 | 1 | 1 | 1
| 0 | 1 | 1 | 0 | 1
| 1 | 0 | 0 | 0 | 1
| 0 | 0 | 1 | 0 | 1
|===

which shows that the formula is valid and so the argument is valid.
This rule of inference has the typically recondite name of..._modus ponens_!!!

Another rule of inference is:

[example]
A {and} B {entails} B

and another:

[example]
A {and} B {entails} A

These two rules are called _{and} reduction_. And so, armed with these rules,
lets find out if the following argument is valid:

[example]
A {and} B {implies} A, B {entails} A

The steps to show this is valid are:

. A {and} B {implies} A (assumption)
. B {implies} A (1. and {and} reduction)
. B (assumption)
. A (2. and 3. and modus ponens)

Case solved! Another one:

[example]
Q, (R {and} P) {and} (R {and} Q) {implies} P {entails} P

. (R {and} P) {and} (R {and} Q) {implies} P (assumption)
. R {and} (R {and} Q) {implies} P (1. and {and} reduction)
. R {and} Q {implies} P (2. and {and} reduction)
. Q {implies} P (3. and {and} reduction)
. Q (assumption)
. P (4. and 5. and modus ponens)

Here's a list of rules of inference:

|===
| Name                   | Rule

| Modus ponens           | (A {implies} B), A {entails} B
| Modus tollens          | (A {implies} B), {not}B {entails} {not}A
| {implies} introduction | A {entails} (B {implies} A)
| {or} introduction      | A {entails} (A {or} B)
| {or} elimination       | (A {implies} C), (B {implies} C), (A {or} B) {entails} C
| {bicond} introduction  | (A {implies} B), (B {implies} A) {entails} (A {bicond} B)
| {bicond} elimination   | (A {bicond} B) {entails} (A {implies} B)
| {and} introduction     | A, B {entails} (A {and} B)
| {and} elimination      | (A {and} B) {entails} A
| {not} elimination      | Assume {not}A, derive B and {not}B {entails} A
| transitive             | A {implies} B, B {implies} C {entails} A {implies} C
|===


:numbered!:
==== Questions

. Show that the rules of inference are valid by using a truth table.
. For all the arguments in the questions for <<_entailment>>, show that they are
  valid by using rules of inference.

==== Answers

. {empty}
.. The following truth table shows that A {and} (A {implies} B) {implies} B is
   valid, and so the rule of inference is valid.
|===
| 1 | 2 | 3             | 4             | 5
| A | B | A {implies} B | A {and} col_3 | col_4 implies B

| 1 | 1 | 1             | 1             | 1
| 0 | 1 | 1             | 0             | 1
| 1 | 0 | 0             | 0             | 1
| 0 | 0 | 1             | 0             | 1
|===
[start=2]
.. The following truth table shows that A {and} B {implies} (A {implies} B) is
   valid, and so the rule of inference is valid.
|===
| 1 | 2 | 3         | 4             | 5
| A | B | A {and} B | A {implies} B | col_3 {implies} col_4

| 1 | 1 | 1         | 1             | 1
| 0 | 1 | 0         | 1             | 1
| 1 | 0 | 0         | 0             | 1
| 0 | 0 | 0         | 1             | 1
|===
[start=3]
.. The following truth table shows that (A {implies} B) {and} {not}B {implies}
   {not}A is valid, and so the rule of inference is valid.
|===
| 1 | 2 | 3             | 4      | 5      | 6                 | 7
| A | B | A {implies} B | {not}B | {not}A | col_3 {and} col_4 | col_6 {implies} col_5

| 1 | 1 | 1             | 0      | 0      | 0                 | 1
| 0 | 1 | 1             | 0      | 1      | 0                 | 1
| 1 | 0 | 0             | 1      | 0      | 0                 | 1
| 0 | 0 | 1             | 1      | 1      | 1                 | 1
|===
[start=4]
.. The following truth table shows that {not}{not}A {implies} A is valid, and so
   the rule of inference is valid.
|===
| A | {not}A | {not}{not}A | {not}{not}A {implies} A

| 1 | 0      | 1           | 1
| 0 | 1      | 0           | 1
|===
[start=5]
.. The following truth table shows that A {and} B {implies} A is valid, and so
   the rule of inference is valid.
|===
| A | B | A {and} B | A {and} B {implies} A

| 1 | 1 | 1         | 1
| 0 | 1 | 0         | 1
| 1 | 0 | 0         | 1
| 0 | 0 | 0         | 1
|===
[start=6]
.. The following truth table shows that A {and} B {implies} A {and} B is
   obviously valid, and so the rule of inference is valid.
[start=7]
.. The following truth table shows that (A {implies} C) {and} (B {implies} C)
   {and} (A {or} B) {implies} C is valid, and so the rule of inference is
   valid.
|===
| 1 | 2 | 3 | 4             | 5             | 6        | 7                 | 8                 | 9
| A | B | C | A {implies} C | B {implies} C | A {or} B | col_4 {and} col_5 | col_7 {and} col_6 | col_8 {implies} C

| 1 | 1 | 1 | 1             | 1             | 1        | 1                 | 1                 | 1
| 0 | 1 | 1 | 1             | 1             | 1        | 1                 | 1                 | 1
| 1 | 0 | 1 | 1             | 1             | 1        | 1                 | 1                 | 1
| 0 | 0 | 1 | 1             | 1             | 0        | 1                 | 0                 | 1
| 1 | 1 | 0 | 0             | 0             | 1        | 0                 | 0                 | 1
| 0 | 1 | 0 | 1             | 0             | 1        | 0                 | 0                 | 1
| 1 | 0 | 0 | 0             | 1             | 1        | 0                 | 0                 | 1
| 0 | 0 | 0 | 1             | 1             | 0        | 1                 | 0                 | 1
|===
[start=8]
.. The following truth table shows that A {implies} A {or} B is valid, and so
   the rule of inference is valid.
|===
| A | B | A {or} B | A {implies} A {or} B

| 1 | 1 | 1        | 1
| 0 | 1 | 1        | 1
| 1 | 0 | 1        | 1
| 0 | 0 | 0        | 1
|===
[start=9]
.. The following truth table shows that (A {or} B) {and} {not}B {implies} A is
   valid, and so the rule of inference is valid.
|===
| 1 | 2 | 3        | 4      | 5                 | 6
| A | B | A {or} B | {not}B | col_3 {and} col_4 | col_5 {implies} A

| 1 | 1 | 1        | 0      | 0                 | 1
| 0 | 1 | 1        | 0      | 0                 | 1
| 1 | 0 | 1        | 1      | 1                 | 1
| 0 | 0 | 0        | 1      | 0                 | 1
|===
[start=10]
.. The following truth table shows that (A {implies} B) {and} (B {implies} C)
   {implies} (A {implies} C) is valid, and so the rule of inference is
   valid.
|===
| 1 | 2 | 3 | 4             | 5             | 6             | 7                 | 8                 | 9
| A | B | C | A {implies} B | B {implies} C | A {implies} C | col_4 {and} col_5 | col_7 {implies} col_6

| 1 | 1 | 1 | 1             | 1             | 1             | 1                 | 1
| 0 | 1 | 1 | 1             | 1             | 1             | 1                 | 1
| 1 | 0 | 1 | 0             | 1             | 1             | 0                 | 1
| 0 | 0 | 1 | 1             | 1             | 1             | 1                 | 1
| 1 | 1 | 0 | 1             | 0             | 0             | 0                 | 1
| 0 | 1 | 0 | 1             | 0             | 1             | 0                 | 1
| 1 | 0 | 0 | 0             | 1             | 0             | 0                 | 1
| 0 | 0 | 0 | 1             | 1             | 1             | 1                 | 1
|===
. {empty}
.. P: It's a silent film. +
   Q: There's no sound. +
   P {implies} Q, P {entails} Q +
   1. P {implies} Q (assumption)
   2. P (assumption)
   3. Q (1. and 2. and modus ponens)
.. A: Scheherazade bought black paint. +
   B: Scheherazade bought grey paint. +
   A {or} B, {not}B {entails} A
   1. A {or} B (assumption)
   2. {not}B (assumption)
   3. A (1. and 2. and {or} syllogism)
.. P: Ben won a tennis match. +
   Q: Toby won a tennis match. +
   {not}(P {and} Q), Q {entails} {not}P
   1. P (assume as part of {not} elimination)
   2. Q (assumption) 
   3. P {and} Q (1. and 2. and {and} introduction)
   4. {not}(P {and} Q) (assumption)
   5. {not}P (3. and 4. and {not} elimination)
.. P: Bill orders 6x. +
   Q: Bill orders Tribute. +
   R: The pub is open. +
   P {or} Q, P {or} Q {implies} R, {not}Q {entails} R {and} P
   1. {not}P (assume for {not} elimination)
   2. {not}Q (assumption)
   3. {not}P {and} {not}Q (1. and 2. {and} introduction)
   4. {not}(P {or} Q) (3. and De Morgan's law)
   5. P {or} Q (assumption)
   6. P (4 and 5 and {not} elimination)
   7. P {or} Q {implies} R (assumption)
   8. R (7 and 5 and modus ponens)
   9. P {and} R (7 and 8 and {and} introduction)
   10. 
.. P: The light switch is on. +
   Q: The light switch is off. +
   P {or} Q, {not}(P {and} Q), {not}P {entails} Q
   1. {not}Q (assume for {not} elimination)
   2. {not}P (assumption)
   3. {not}P {and} {not}Q (1 and 2 and {and} introduction)
   4. {not}(P {or} Q) (3 and De Morgan's laws)
   5. P {or} Q (assumption)
   6. Q (4 and 5 and {not} elimination)




:numbered:
=== Sentential Logic: Summary

|===
| Name | Rule

| {or} associativity
| (P {or} (Q {or} R)) {equiv} (\(P {or} Q) {or} R)

| {and} associativity
| (P {and} (Q {and} R)) {equiv} (\(P {and} Q) {and} R)

| {bicond} associativity
| (P {bicond} (Q {bicond} R)) {equiv} (\(P {bicond} Q) {bicond} R)

| {or} commutativity
| (P {or} Q) {equiv} (Q {or} P)

| {and} commutativity
| (P {and} Q) {equiv} (Q {and} P)
|===

==== Answers

Answers on their way...

:numbered:
=== Rosetta Stone

[[img-rosetta]]
.http://commons.wikimedia.org/wiki/File:Rosetta_Stone.JPG#mediaviewer/File:Rosetta_Stone.JPG[Rosetta Stone] by http://commons.wikimedia.org/wiki/User:Biopics[Hans Hillewaert] - Own work. Licensed under http://creativecommons.org/licenses/by-sa/4.0[CC BY-SA 4.0] via http://commons.wikimedia.org/wiki/[Wikimedia Commons].
image::rosetta.jpg[Rosetta Stone]

I've found that in maths, the same thing is often called different names by
different authors. Also, some authors take different philosophical approaches to
the same area of maths. This point of this section is to help us understand
what other authors are saying, in terms that we already understand.


==== Sentential Logic versus Propositional Logic versus Boolean Algebra

Some authors talk of Sentential Logic, and some talk of Propositional Logic.
This is a philosophical difference. Say there are two statements that mean the
same thing but use a different form of words. The sentential school of thought
uses a different label for each statement, but the proposition school would use
just one label.

Where does Boolean Algebra come in? Once you've decided on labels and formulas,
then as far as I can see Propositional Logic and Sentential logic are both
Boolean Algebras.


==== Functional Notation Versus Operational Notation

The formula:

and(or(A, B), C)

would be written in operational notation as:

(\(A {or} B) {and} C)

I've chosen to use functional notation because functions are more general than
operations. So in learning maths you have to learn functional notation, but you
don't necessarily have to learn operational notation.


==== Synonyms

[cols="2*", options="header"]
|===
| Name
| Synonym

| True, 1
| T

| False, 0
| F

| Function
| Operation, connective

| Sentential Logic
| Sentential Calculus

| Not
| ~, negation, {not}

| And
| Conjunction, {and}

| Or
| Disjunction, {or}

| Implies
| Conditional, {implies}, material implication

| Atomic formula
| Atom, simple proposition, atomic sentence, simple sentence, proposition
  constant, logical constant

| Compound formula
| compound proposition, compound sentence

| <<_interpretations,Interpretation>>
| Truth assignment

| Valid formula
| Tautology

| Unsatisfiable formula
| Contradiction

| {equiv}
| &#x21D4;

| Identity
| Rule of replacement
|===

* All the rules of inference. and equivalence



==== Antecedent and Consequent

The formula before the {implies} is called the _antecedent_ and the formula
after the {implies} is the _consequent_.


==== Contingent

A formula that is neither valid nor unsatisfiable is said to be _contingent_.


==== Precedence

In many parts of the Ivory Tower they adopt the convention of _precedence_ of
functions
Let's say we've got _three_ atomic formulas P, Q and R. What's the truth table for:

[example]
P {or} Q {and} R

But wait, do I do the P {or} Q first and then apply the {and} to the result? Or
do I do Q {and} R first and then apply P {or} to the result? And does it even
matter? The Rules Of Propositional Logic that I read while in the Ivory Tower
are quite clear on the point. They say that {and} is evaluated before {or}.
Okay, so the truth table for P {or} Q {and} R is:

|===
| P | Q | R | Q {and} R | P {or} Q {and} R

| 1 | 1 | 1 | 1         | 1
| 0 | 1 | 1 | 1         | 1
| 1 | 0 | 1 | 0         | 1
| 0 | 0 | 1 | 0         | 0
| 1 | 1 | 0 | 0         | 1
| 0 | 1 | 0 | 0         | 0
| 1 | 0 | 0 | 0         | 1
| 0 | 0 | 0 | 0         | 0
|===

So what would you write if you want to do P {or} Q and then apply {and} R? The
Rules say that anything in brackets gets evaluated first. So you'd write:

[example]
(P {or} Q) {and} R

and the truth table is:

|===
| P | Q | R | P {or} Q | (P {or} Q) {and} R

| 1 | 1 | 1 | 1         | 1
| 0 | 1 | 1 | 1         | 1
| 1 | 0 | 1 | 1         | 1
| 0 | 0 | 1 | 0         | 0
| 1 | 1 | 0 | 1         | 0
| 0 | 1 | 0 | 1         | 0
| 1 | 0 | 0 | 1         | 0
| 0 | 0 | 0 | 0         | 0
|===

:numbered!:
==== Questions

. Write out the truth tables for:
.. P {and} Q {or} R
.. P {and} Q {and} R
.. P {or} Q {or} R
.. P {and} (Q {or} R)


==== Answers

. {empty}
.. {empty}
|===
| P | Q | R | P {and} Q | P {and} Q {or} R

| 1 | 1 | 1 | 1         | 1
| 0 | 1 | 1 | 0         | 1
| 1 | 0 | 1 | 0         | 1
| 0 | 0 | 1 | 0         | 1
| 1 | 1 | 0 | 1         | 1
| 0 | 1 | 0 | 0         | 0
| 1 | 0 | 0 | 0         | 0
| 0 | 0 | 0 | 0         | 0
|===
[start=2]
.. {empty}
|===
| P | Q | R | P {and} Q | P {and} Q {and} R

| 1 | 1 | 1 | 1         | 1
| 0 | 1 | 1 | 0         | 0
| 1 | 0 | 1 | 0         | 0
| 0 | 0 | 1 | 0         | 0
| 1 | 1 | 0 | 1         | 0
| 0 | 1 | 0 | 0         | 0
| 1 | 0 | 0 | 0         | 0
| 0 | 0 | 0 | 0         | 0
|===
[start=3]
.. {empty}
|===
| P | Q | R | P {or} Q | P {or} Q {or} R

| 1 | 1 | 1 | 1         | 1
| 0 | 1 | 1 | 1         | 1
| 1 | 0 | 1 | 1         | 1
| 0 | 0 | 1 | 0         | 1
| 1 | 1 | 0 | 1         | 1
| 0 | 1 | 0 | 1         | 1
| 1 | 0 | 0 | 1         | 1
| 0 | 0 | 0 | 0         | 0
|===
[start=4]
.. {empty}
|===
| P | Q | R | Q {or} R | P {and} (Q {or} R)

| 1 | 1 | 1 | 1         | 1
| 0 | 1 | 1 | 1         | 0
| 1 | 0 | 1 | 1         | 1
| 0 | 0 | 1 | 0         | 0
| 1 | 1 | 0 | 1         | 1
| 0 | 1 | 0 | 1         | 0
| 1 | 0 | 0 | 0         | 0
| 0 | 0 | 0 | 0         | 0
|===

=== Sources

* http://en.wikibooks.org/wiki/Formal_Logic/Sentential_Logic (Referred to this
  throughout, very good.)
* Mathematics for Computing by Robert Callen 1998, Letts Educational. (This
  book first got me going on propositional logic.)
* http://en.wikipedia.org/wiki/Propositional_calculus (This and related pages
  on Wikipedia continually useful).
* http://logic.stanford.edu/intrologic/chapters/cover.html (Excellent notes).
* https://www.trinity.edu/cbrown/logic/alter.pdf (Shows the different systems of
  propositional logic)


== Number Theory

The study of integers.


== Real Analysis

The study of real numbers. Also known as calculus.

== Complex Analysis

The study of complex numbers.









